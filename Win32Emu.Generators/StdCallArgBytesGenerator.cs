using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Win32Emu.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class StdCallArgBytesGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find methods with [DllModuleExport] attribute for new modules
		var attributedMethods = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) => node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0,
				static (ctx, _) =>
				{
					var method = ctx.SemanticModel.GetDeclaredSymbol((MethodDeclarationSyntax)ctx.Node) as IMethodSymbol;
					if (method is null)
						return null;

					// Check if method has DllModuleExport attribute
					var hasDllExportAttr = method.GetAttributes()
						.Any(attr => attr.AttributeClass?.Name == "DllModuleExportAttribute");

					return hasDllExportAttr ? method : null;
				})
			.Where(static s => s is not null)!
			.Select(static (s, _) => s!);

		// LEGACY: Find all unsafe methods in Kernel32Module for backward compatibility
		var unsafeMethods = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) => node is MethodDeclarationSyntax m && m.Modifiers.Any(Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsafeKeyword),
				static (ctx, _) =>
					ctx.SemanticModel.GetDeclaredSymbol((MethodDeclarationSyntax)ctx.Node) as IMethodSymbol)
			.Where(static s => s is not null && s.ContainingType.ToDisplayString() == "Win32Emu.Win32.Kernel32Module")!
			.Select(static (s, _) => s!);

		// Combine both sources
		var allMethods = attributedMethods.Collect()
			.Combine(unsafeMethods.Collect())
			.Select(static (pair, _) => pair.Left.Concat(pair.Right).ToList());

		// Filter to module classes and compute arg bytes.
		var exportMeta = allMethods
			.Select(static (methods, _) =>
			{
				return methods
					.Where(sym =>
					{
						var containingType = sym.ContainingType.ToDisplayString();
						return containingType.StartsWith("Win32Emu.Win32.Modules.") ||
						       containingType == "Win32Emu.Win32.Kernel32Module";
					})
					.Select(sym =>
					{
						var containingType = sym.ContainingType.Name;
						var dllName = GetDllNameFromModuleClassName(containingType);
						var argBytes = sym.Parameters.Sum(p => GetParamSize(p.Type));
						return new ExportEntry(dllName, sym.Name, argBytes);
					})
					.ToList();
			});

		context.RegisterSourceOutput(exportMeta, static (spc, entries) =>
		{
			// Group by DLL and method name to handle duplicates
			var byDll = entries
				.GroupBy(e => e.DllName)
				.OrderBy(g => g.Key)
				.ToList();

			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine(
				"""
				namespace Win32Emu.Win32
				{
				    public static class StdCallMeta
				    {
				        public static int GetArgBytes(string dll, string export)
				        {
				            switch ((dll.ToUpperInvariant(), export))
				            {
				""");

			foreach (var dllGroup in byDll)
			{
				var distinct = dllGroup
					.GroupBy(e => e.MethodName)
					.Select(g => g.First())
					.OrderBy(e => e.MethodName);

				foreach (var e in distinct)
				{
					sb.AppendLine($"                case (\"{e.DllName}\", \"{e.MethodName}\"): return {e.ArgBytes};");
				}
			}

			sb.AppendLine(
				"""
				                default: throw new System.InvalidOperationException($"Missing arg bytes for {dll}!{export}");
				            }
				        }
				    }
				}
				""");

			spc.AddSource("StdCallMeta.g.cs", sb.ToString());
		});

		// Generate DllModuleExportInfo helper class
		var exportInfoMeta = attributedMethods
			.Collect()
			.Select(static (methods, _) =>
			{
				return methods
					.Where(sym =>
					{
						var containingType = sym.ContainingType.ToDisplayString();
						return containingType.StartsWith("Win32Emu.Win32.Modules.") ||
						       containingType == "Win32Emu.Win32.Kernel32Module";
					})
					.Select(sym =>
					{
						var containingType = sym.ContainingType.Name;
						var methodName = sym.Name;
						
						// Get all DllModuleExport attributes
						var exportAttrs = sym.GetAttributes()
							.Where(attr => attr.AttributeClass?.Name == "DllModuleExportAttribute")
							.Select(attr =>
							{
								uint ordinal = 0u;
								if (attr.ConstructorArguments.Length > 0)
								{
									var ordinalValue = attr.ConstructorArguments[0].Value;
									if (ordinalValue != null)
									{
										// Handle both int and uint
										ordinal = ordinalValue is uint u ? u : Convert.ToUInt32(ordinalValue);
									}
								}
								
								uint? entryPoint = null;
								string? version = null;
								
								foreach (var named in attr.NamedArguments)
								{
									if (named.Key == "EntryPoint" && named.Value.Value != null)
									{
										var epValue = named.Value.Value;
										entryPoint = epValue is uint u ? u : Convert.ToUInt32(epValue);
									}
									else if (named.Key == "Version" && named.Value.Value != null)
										version = (string)named.Value.Value;
								}
								
								return new ExportAttributeInfo(ordinal, entryPoint, version);
							})
							.ToList();
						
						return new ExportMethodInfo(containingType, methodName, exportAttrs);
					})
					.ToList();
			});

		context.RegisterSourceOutput(exportInfoMeta, static (spc, entries) =>
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine(
				"""
				namespace Win32Emu.Win32
				{
				    /// <summary>
				    /// Helper class to query metadata about DLL module exports.
				    /// Generated at compile-time from [DllModuleExport] attributes.
				    /// </summary>
				    public static class DllModuleExportInfo
				    {
				        /// <summary>
				        /// Checks if a given export function is implemented in a module.
				        /// </summary>
				        /// <param name="moduleName">The name of the module class (e.g., "DPlayXModule")</param>
				        /// <param name="exportName">The export function name to check</param>
				        /// <param name="version">Optional version string to match. If null, checks if any version is implemented.</param>
				        /// <returns>True if the export is implemented, false otherwise</returns>
				        public static bool IsExportImplemented(string moduleName, string exportName, string? version = null)
				        {
				            switch ((moduleName, exportName.ToUpperInvariant()))
				            {
				""");

			// Generate switch cases for each export
			foreach (var export in entries.OrderBy(e => e.ModuleName).ThenBy(e => e.MethodName))
			{
				// Check if this export has version-specific attributes
				var hasVersions = export.Attributes.Any(a => a.Version != null);
				
				if (!hasVersions)
				{
					// No version-specific, simple case
					sb.AppendLine($"                case (\"{export.ModuleName}\", \"{export.MethodName.ToUpperInvariant()}\"): return true;");
				}
				else
				{
					// Has versions, generate version checks
					foreach (var attr in export.Attributes)
					{
						if (attr.Version != null)
						{
							sb.AppendLine($"                case (\"{export.ModuleName}\", \"{export.MethodName.ToUpperInvariant()}\") when version == \"{attr.Version}\": return true;");
						}
						else
						{
							sb.AppendLine($"                case (\"{export.ModuleName}\", \"{export.MethodName.ToUpperInvariant()}\") when version == null: return true;");
						}
					}
				}
			}

			sb.AppendLine(
				"""
				                default: return false;
				            }
				        }

				        /// <summary>
				        /// Gets all exports implemented in a module.
				        /// </summary>
				        /// <param name="moduleName">The name of the module class</param>
				        /// <returns>Dictionary mapping export names to their ordinals (first version found)</returns>
				        public static System.Collections.Generic.Dictionary<string, uint> GetAllExports(string moduleName)
				        {
				            var exports = new System.Collections.Generic.Dictionary<string, uint>(System.StringComparer.OrdinalIgnoreCase);
				            switch (moduleName)
				            {
				""");

			// Group by module
			var byModule = entries
				.GroupBy(e => e.ModuleName)
				.OrderBy(g => g.Key);

			foreach (var moduleGroup in byModule)
			{
				sb.AppendLine($"                case \"{moduleGroup.Key}\":");
				foreach (var export in moduleGroup.OrderBy(e => e.MethodName))
				{
					var firstOrdinal = export.Attributes.Count > 0 ? export.Attributes[0].Ordinal : 0u;
					sb.AppendLine($"                    exports[\"{export.MethodName}\"] = {firstOrdinal};");
				}
				sb.AppendLine("                    break;");
			}

			sb.AppendLine(
				"""
				            }
				            return exports;
				        }
				    }
				}
				""");

			spc.AddSource("DllModuleExportInfo.g.cs", sb.ToString());
		});
	}

	private static string GetDllNameFromModuleClassName(string moduleClassName)
	{
		// Convert class names like "Kernel32Module" to "KERNEL32.DLL"
		return moduleClassName switch
		{
			"Kernel32Module" => "KERNEL32.DLL",
			"User32Module" => "USER32.DLL",
			"Gdi32Module" => "GDI32.DLL",
			"DDrawModule" => "DDRAW.DLL",
			"DInputModule" => "DINPUT.DLL",
			"DSoundModule" => "DSOUND.DLL",
			"DPlayXModule" => "DPLAYX.DLL",
			"WinMMModule" => "WINMM.DLL",
			"Glide2xModule" => "GLIDE2X.DLL",
			_ => moduleClassName.ToUpperInvariant()
		};
	}

	private static int GetParamSize(ITypeSymbol t)
	{
		if (t is IPointerTypeSymbol)
		{
			return 4;
		}

		var name = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		return name switch
		{
			"global::System.UInt32" or "global::System.Int32" or "global::System.UInt16" or "global::System.Int16"
				or "global::System.Byte" or "global::System.SByte" or "global::System.Boolean" => 4,
			"global::System.UInt64" or "global::System.Int64" or "global::System.Double" => 8,
			_ => 4,
		};
	}

	private readonly struct ExportEntry(string dllName, string methodName, int argBytes)
	{
		public string DllName { get; } = dllName;
		public string MethodName { get; } = methodName;
		public int ArgBytes { get; } = argBytes;
	}

	private readonly struct ExportAttributeInfo(uint ordinal, uint? entryPoint, string? version)
	{
		public uint Ordinal { get; } = ordinal;
		public uint? EntryPoint { get; } = entryPoint;
		public string? Version { get; } = version;
	}

	private readonly struct ExportMethodInfo(string moduleName, string methodName, List<ExportAttributeInfo> attributes)
	{
		public string ModuleName { get; } = moduleName;
		public string MethodName { get; } = methodName;
		public List<ExportAttributeInfo> Attributes { get; } = attributes;
	}
}