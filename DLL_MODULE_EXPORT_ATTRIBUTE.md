# DLL Module Export Attribute Documentation

This document explains how to use the `[DllModuleExport]` attribute to add metadata to DLL module functions in Win32Emu.

## Overview

The `DllModuleExportAttribute` allows you to annotate methods in module classes with export metadata including:
- **Ordinal number**: The export ordinal for the function
- **Entry point address** (optional): The memory address of the function's entry point
- **DLL version** (optional): The specific DLL version this export applies to

## Basic Usage

### Simple Export with Ordinal

```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
    return 0;
}
```

### Export with Entry Point

```csharp
[DllModuleExport(2, EntryPoint = 0x00006C19)]
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation
    return 0;
}
```

### Export with Version-Specific Metadata

You can apply multiple attributes to support different DLL versions:

```csharp
[DllModuleExport(ordinal: 2, EntryPoint = 0x00006C19, Version = "5.3.2600.5512")]  // Windows XP
[DllModuleExport(ordinal: 2, EntryPoint = 0x00005A21, Version = "4.09.00.0904")]   // Windows 95
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation works for both versions
    return 0;
}
```

## Runtime Checking

Use the `DllModuleExportInfo` helper class to check if exports are implemented:

### Check if an Export is Implemented

```csharp
using Win32Emu.Win32;
using Win32Emu.Win32.Modules;

var moduleType = typeof(DPlayXModule);

// Check if function exists
bool isImplemented = DllModuleExportInfo.IsExportImplemented(moduleType, "DirectPlayCreate");
if (isImplemented)
{
    Console.WriteLine("DirectPlayCreate is implemented");
}

// Check for specific version
bool isImplementedXP = DllModuleExportInfo.IsExportImplemented(
    moduleType, 
    "DirectPlayEnumerateA", 
    version: "5.3.2600.5512"
);
```

### Get All Exports from a Module

```csharp
var exports = DllModuleExportInfo.GetAllExports(moduleType);
foreach (var export in exports)
{
    Console.WriteLine($"{export.Key} => Ordinal {export.Value}");
}
```

### Get Detailed Attributes for an Export

```csharp
var attributes = DllModuleExportInfo.GetExportAttributes(moduleType, "DirectPlayCreate");
foreach (var attr in attributes)
{
    Console.WriteLine($"Ordinal: {attr.Ordinal}");
    Console.WriteLine($"EntryPoint: {attr.EntryPoint?.ToString("X")}");
    Console.WriteLine($"Version: {attr.Version ?? "any"}");
}
```

## Source Generator Integration

The `StdCallArgBytesGenerator` automatically detects methods with `[DllModuleExport]` and generates the `StdCallMeta.GetArgBytes()` method for argument size calculation.

### Supported Modules

The generator automatically processes exports from:
- `Win32Emu.Win32.Kernel32Module` (backward compatible with `unsafe` keyword)
- `Win32Emu.Win32.Modules.DPlayXModule`
- `Win32Emu.Win32.Modules.DDrawModule`
- `Win32Emu.Win32.Modules.DInputModule`
- `Win32Emu.Win32.Modules.DSoundModule`
- `Win32Emu.Win32.Modules.User32Module`
- `Win32Emu.Win32.Modules.Gdi32Module`
- `Win32Emu.Win32.Modules.WinMMModule`
- `Win32Emu.Win32.Modules.Glide2xModule`

### Example Generated Code

```csharp
// <auto-generated/>
namespace Win32Emu.Win32
{
    public static class StdCallMeta
    {
        public static int GetArgBytes(string dll, string export)
        {
            switch ((dll.ToUpperInvariant(), export))
            {
                case ("DPLAYX.DLL", "DirectPlayCreate"): return 12;
                case ("DPLAYX.DLL", "DirectPlayEnumerateA"): return 8;
                // ... more exports
                default: throw new System.InvalidOperationException($"Missing arg bytes for {dll}!{export}");
            }
        }
    }
}
```

## Best Practices

1. **Always specify ordinals**: Export ordinals are required for proper DLL emulation
2. **Use version strings for multiple versions**: When emulating different Windows versions, use version-specific attributes
3. **Document entry points**: If known, include entry point addresses for debugging
4. **Keep methods private**: Export methods should typically be private and called via `TryInvokeUnsafe()`
5. **Maintain GetExportOrdinals()**: For now, keep the manual `GetExportOrdinals()` dictionary method for compatibility

## Migration Guide

### Converting Existing Modules

Before:
```csharp
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

public Dictionary<string, uint> GetExportOrdinals()
{
    return new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase)
    {
        { "DirectPlayCreate", 1 },
    };
}
```

After:
```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

// GetExportOrdinals() can be auto-generated in the future or use DllModuleExportInfo
public Dictionary<string, uint> GetExportOrdinals()
{
    return DllModuleExportInfo.GetAllExports(typeof(DPlayXModule));
}
```

## Future Enhancements

Potential future improvements:
- Auto-generate `GetExportOrdinals()` from attributes
- Support for forwarded exports
- Automatic version detection based on emulated Windows version
- Export by name vs. ordinal distinction
- Better integration with `GetProcAddress` implementation
