using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Win32Emu.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class StdCallArgBytesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all unsafe methods.
        var methodSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is MethodDeclarationSyntax m && m.Modifiers.Any(SyntaxKind.UnsafeKeyword),
                static (ctx, _) => ctx.SemanticModel.GetDeclaredSymbol((MethodDeclarationSyntax)ctx.Node) as IMethodSymbol)
            .Where(static s => s is not null)!
            .Select(static (s, _) => s!);

        // Filter to Kernel32Module methods and compute arg bytes.
        var exportMeta = methodSymbols
            .Where(static sym => sym!.ContainingType.ToDisplayString() == "Win32Emu.Win32.Kernel32Module")
            .Select(static (sym, _) => new ExportEntry(sym!.Name, sym.Parameters.Sum(p => GetParamSize(p.Type))))
            .Collect();

        context.RegisterSourceOutput(exportMeta, static (spc, entries) =>
        {
            // De-duplicate by method name in case of partials/overloads.
            var distinct = entries
                .GroupBy(e => e.Name)
                .Select(g => new ExportEntry(g.Key, g.First().ArgBytes))
                .ToList();

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine(
                """
                namespace Win32Emu.Win32
                {
                    public static class StdCallMeta
                    {
                        public static int GetArgBytes(string dll, string export)
                        {
                            switch ((dll.ToUpperInvariant(), export))
                            {
                """);

            foreach (var e in distinct)
            {
                sb.AppendLine($"                case (\"KERNEL32.DLL\", \"{e.Name}\"): return {e.ArgBytes};");
            }

            sb.AppendLine(
                """
                                default: throw new System.InvalidOperationException($"Missing arg bytes for {dll}!{export}");
                            }
                        }
                    }
                }
                """);

            spc.AddSource("StdCallMeta.g.cs", sb.ToString());
        });
    }

    private static int GetParamSize(ITypeSymbol t)
    {
        if (t is IPointerTypeSymbol)
            return 4;
        var name = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return name switch
        {
            "global::System.UInt32" or "global::System.Int32" or "global::System.UInt16" or "global::System.Int16" or "global::System.Byte" or "global::System.SByte" or "global::System.Boolean" => 4,
            "global::System.UInt64" or "global::System.Int64" or "global::System.Double" => 8,
            _ => 4,
        };
    }

    private readonly struct ExportEntry(string Name, int ArgBytes)
    {
	    public string Name { get; } = Name;
	    public int ArgBytes { get; } = ArgBytes;

	    public void Deconstruct(out string Name, out int ArgBytes)
	    {
		    Name = this.Name;
		    ArgBytes = this.ArgBytes;
	    }
    }
}