# DLL Module Export Attribute Documentation

This document explains how to use the `[DllModuleExport]` attribute to add metadata to DLL module functions in Win32Emu.

## Overview

The `DllModuleExportAttribute` allows you to annotate methods in module classes with export metadata including:
- **Ordinal number**: The export ordinal for the function
- **Entry point address** (optional): The memory address of the function's entry point
- **DLL version** (optional): The specific DLL version this export applies to

## Basic Usage

### Simple Export with Ordinal

```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
    return 0;
}
```

### Export with Entry Point

```csharp
[DllModuleExport(2, EntryPoint = 0x00006C19)]
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation
    return 0;
}
```

### Export with Version-Specific Metadata

You can apply multiple attributes to support different DLL versions:

```csharp
[DllModuleExport(ordinal: 2, EntryPoint = 0x00006C19, Version = "5.3.2600.5512")]  // Windows XP
[DllModuleExport(ordinal: 2, EntryPoint = 0x00005A21, Version = "4.09.00.0904")]   // Windows 95
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation works for both versions
    return 0;
}
```

## Runtime Checking

Use the `DllModuleExportInfo` helper class to check if exports are implemented. This class is **generated at compile-time** from the `[DllModuleExport]` attributes.

### Check if an Export is Implemented

```csharp
using Win32Emu.Win32;

// Check if function exists (using module name as string)
bool isImplemented = DllModuleExportInfo.IsExportImplemented("DPlayXModule", "DirectPlayCreate");
if (isImplemented)
{
    Console.WriteLine("DirectPlayCreate is implemented");
}

// Check for specific version
bool isImplementedXP = DllModuleExportInfo.IsExportImplemented(
    "DPlayXModule", 
    "DirectPlayEnumerateA", 
    version: "5.3.2600.5512"
);
```

### Get All Exports from a Module

```csharp
var exports = DllModuleExportInfo.GetAllExports("DPlayXModule");
foreach (var export in exports)
{
    Console.WriteLine($"{export.Key} => Ordinal {export.Value}");
}
```

**Note:** The `DllModuleExportInfo` class is automatically generated at compile-time by analyzing `[DllModuleExport]` attributes. No reflection is used at runtime, making it fast and AOT-friendly.

## Source Generator Integration

The `StdCallArgBytesGenerator` source generator processes `[DllModuleExport]` attributes at compile-time and generates two helper classes:

### 1. StdCallMeta - For Argument Size Calculation

Automatically generates the `StdCallMeta.GetArgBytes()` method for argument size calculation.

### Supported Modules

The generator automatically processes exports from:
- `Win32Emu.Win32.Kernel32Module` (backward compatible with `unsafe` keyword)
- `Win32Emu.Win32.Modules.DPlayXModule`
- `Win32Emu.Win32.Modules.DDrawModule`
- `Win32Emu.Win32.Modules.DInputModule`
- `Win32Emu.Win32.Modules.DSoundModule`
- `Win32Emu.Win32.Modules.User32Module`
- `Win32Emu.Win32.Modules.Gdi32Module`
- `Win32Emu.Win32.Modules.WinMMModule`
- `Win32Emu.Win32.Modules.Glide2xModule`

### Example Generated Code

**StdCallMeta.g.cs:**
```csharp
// <auto-generated/>
namespace Win32Emu.Win32
{
    public static class StdCallMeta
    {
        public static int GetArgBytes(string dll, string export)
        {
            switch ((dll.ToUpperInvariant(), export))
            {
                case ("DPLAYX.DLL", "DirectPlayCreate"): return 12;
                case ("DPLAYX.DLL", "DirectPlayEnumerateA"): return 8;
                // ... more exports
                default: throw new System.InvalidOperationException($"Missing arg bytes for {dll}!{export}");
            }
        }
    }
}
```

### 2. DllModuleExportInfo - For Export Metadata Queries

Automatically generates the `DllModuleExportInfo` helper class with methods to query export information without using reflection.

**DllModuleExportInfo.g.cs:**
```csharp
// <auto-generated/>
namespace Win32Emu.Win32
{
    public static class DllModuleExportInfo
    {
        public static bool IsExportImplemented(string moduleName, string exportName, string? version = null)
        {
            switch ((moduleName, exportName.ToUpperInvariant()))
            {
                case ("DPlayXModule", "DIRECTPLAYCREATE"): return true;
                case ("DPlayXModule", "DIRECTPLAYENUMERATEA"): return true;
                // ... more exports
                default: return false;
            }
        }

        public static Dictionary<string, uint> GetAllExports(string moduleName)
        {
            var exports = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
            switch (moduleName)
            {
                case "DPlayXModule":
                    exports["DirectPlayCreate"] = 1;
                    exports["DirectPlayEnumerateA"] = 2;
                    break;
                // ... more modules
            }
            return exports;
        }
    }
}
```

**Benefits of Source Generation:**
- **No reflection** - All lookups are compile-time switch statements
- **Type-safe** - Compiler errors if module names are wrong
- **Fast** - O(1) lookups instead of reflection overhead
- **AOT-friendly** - Works with ahead-of-time compilation
- **Deterministic** - Generated from source, not runtime introspection

## Best Practices

1. **Always specify ordinals**: Export ordinals are required for proper DLL emulation
2. **Use version strings for multiple versions**: When emulating different Windows versions, use version-specific attributes
3. **Document entry points**: If known, include entry point addresses for debugging
4. **Keep methods private**: Export methods should typically be private and called via `TryInvokeUnsafe()`
5. **Use module name strings**: When calling `DllModuleExportInfo` methods, use the exact module class name (e.g., "DPlayXModule")

## Migration Guide

### Converting Existing Modules

Before:
```csharp
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

public Dictionary<string, uint> GetExportOrdinals()
{
    return new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase)
    {
        { "DirectPlayCreate", 1 },
    };
}
```

After:
```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

// GetExportOrdinals() can now use the generated helper
public Dictionary<string, uint> GetExportOrdinals()
{
    return DllModuleExportInfo.GetAllExports("DPlayXModule");
}
```

## Future Enhancements

Potential future improvements:
- Auto-generate `GetExportOrdinals()` from attributes
- Support for forwarded exports
- Automatic version detection based on emulated Windows version
- Export by name vs. ordinal distinction
- Better integration with `GetProcAddress` implementation
