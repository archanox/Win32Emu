using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Win32Emu.Generators;

[Generator]
public class StdCallArgBytesGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{
		context.RegisterForSyntaxNotifications(() => new Receiver());
	}

	public void Execute(GeneratorExecutionContext context)
	{
		if (context.SyntaxReceiver is not Receiver rx)
			return;

		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine(
			"""
			namespace Win32Emu.Win32
			{
				public static class StdCallMeta
				{
					public static int GetArgBytes(string dll, string export)
					{
						switch ((dll.ToUpperInvariant(), export))
						{
			""");

		foreach (var method in rx.Candidates)
		{
			var model = context.Compilation.GetSemanticModel(method.SyntaxTree);
			if (model.GetDeclaredSymbol(method) is not { } sym)
				continue;

			var type = sym.ContainingType;

			// Only generate for Kernel32Module for now
			if (type.ToDisplayString() != "Win32Emu.Win32.Kernel32Module")
				continue;

			var exportName = sym.Name;
			// Only unsafe exports we actually call directly (private or public)
			var total = sym.Parameters.Sum(p => GetParamSize(p.Type));
			sb.AppendLine($"\t\t\t\tcase (\"KERNEL32.DLL\", \"{exportName}\"): return {total};");
		}

		sb.AppendLine(
			"""
							default: throw new InvalidOperationException($"Missing arg bytes for {dll}!{export}");
						}
					}
				}
			}
			""");
		context.AddSource("StdCallMeta.g.cs", sb.ToString());
	}

	private static int GetParamSize(ITypeSymbol t)
	{
		if (t is IPointerTypeSymbol)
			return 4;
		var name = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		return name switch
		{
			"global::System.UInt32" or "global::System.Int32" or "global::System.UInt16" or "global::System.Int16"
				or "global::System.Byte" or "global::System.SByte" or "global::System.Boolean" => 4,
			"global::System.UInt64" or "global::System.Int64" or "global::System.Double" => 8,
			_ => 4,
		};
	}

	private sealed class Receiver : ISyntaxReceiver
	{
		public List<MethodDeclarationSyntax> Candidates { get; } = [];

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			if (syntaxNode is MethodDeclarationSyntax m && m.Modifiers.Any(SyntaxKind.UnsafeKeyword))
				Candidates.Add(m);
		}
	}
}