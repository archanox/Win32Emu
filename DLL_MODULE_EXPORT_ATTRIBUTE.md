# DLL Module Export Attribute Documentation

This document explains how to use the `[DllModuleExport]` attribute to add metadata to DLL module functions in Win32Emu.

## Overview

The `DllModuleExportAttribute` allows you to annotate methods in module classes with export metadata including:
- **Ordinal number**: The export ordinal for the function
- **Entry point address** (optional): The memory address of the function's entry point
- **DLL version** (optional): The specific DLL version this export applies to

## Basic Usage

### Simple Export with Ordinal

```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
    return 0;
}
```

### Export with Entry Point

```csharp
[DllModuleExport(2, EntryPoint = 0x00006C19)]
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation
    return 0;
}
```

### Export with Version-Specific Metadata

You can apply multiple attributes to support different DLL versions:

```csharp
[DllModuleExport(ordinal: 2, EntryPoint = 0x00006C19, Version = "5.3.2600.5512")]  // Windows XP
[DllModuleExport(ordinal: 2, EntryPoint = 0x00005A21, Version = "4.09.00.0904")]   // Windows 95
private unsafe uint DirectPlayEnumerateA(uint pCallback, uint pContext)
{
    // Implementation works for both versions
    return 0;
}
```

### Forwarded Exports

Forwarded exports redirect to another DLL's export. This is commonly used in Windows where many KERNEL32.DLL functions forward to KERNELBASE.DLL:

```csharp
// In KERNEL32.DLL module
[DllModuleExport(48, ForwardedTo = "KERNELBASE.GetVersionEx")]
private unsafe uint GetVersionEx()
{
    // This method will never be called
    // GetProcAddress will automatically resolve to KERNELBASE.GetVersionEx
    throw new NotImplementedException("This export is forwarded to KERNELBASE.GetVersionEx");
}
```

**How it works:**
1. When `GetProcAddress` is called for a forwarded export, it automatically resolves the forwarding chain
2. The target DLL is loaded if not already loaded
3. The target export is looked up recursively
4. The final address is returned

**Forwarding Format:**
- Simple forwarding: `ForwardedTo = "TARGETDLL.ExportName"`
- DLL extension is optional: `"KERNELBASE.GetVersionEx"` or `"KERNELBASE.DLL.GetVersionEx"`

## Runtime Checking

Use the `DllModuleExportInfo` helper class to check if exports are implemented. This class is **generated at compile-time** from the `[DllModuleExport]` attributes.

### Check if an Export is Implemented

```csharp
using Win32Emu.Win32;

// Check if function exists (using DLL filename)
bool isImplemented = DllModuleExportInfo.IsExportImplemented("DPLAYX.DLL", "DirectPlayCreate");
if (isImplemented)
{
    Console.WriteLine("DirectPlayCreate is implemented");
}

// Check for specific version
bool isImplementedXP = DllModuleExportInfo.IsExportImplemented(
    "DPLAYX.DLL", 
    "DirectPlayEnumerateA", 
    version: "5.3.2600.5512"
);
```

### Get All Exports from a Module

```csharp
var exports = DllModuleExportInfo.GetAllExports("DPLAYX.DLL");
foreach (var export in exports)
{
    Console.WriteLine($"{export.Key} => Ordinal {export.Value}");
}
```

### Check if an Export is Forwarded

```csharp
// Check if an export is forwarded
string? forwardedTo = DllModuleExportInfo.GetForwardedExport("KERNEL32.DLL", "GetVersionEx");
if (forwardedTo != null)
{
    Console.WriteLine($"GetVersionEx is forwarded to {forwardedTo}");
    // Output: "GetVersionEx is forwarded to KERNELBASE.GetVersionEx"
}

// Returns null for non-forwarded exports
string? notForwarded = DllModuleExportInfo.GetForwardedExport("KERNEL32.DLL", "GetVersion");
// notForwarded is null because GetVersion is not forwarded
```

**Note:** The `DllModuleExportInfo` class is automatically generated at compile-time by analyzing `[DllModuleExport]` attributes. No reflection is used at runtime, making it fast and AOT-friendly.

## Source Generator Integration

The `StdCallArgBytesGenerator` source generator processes `[DllModuleExport]` attributes at compile-time and generates two helper classes:

### 1. StdCallMeta - For Argument Size Calculation

Automatically generates the `StdCallMeta.GetArgBytes()` method for argument size calculation.

### Supported Modules

The generator automatically processes exports from:
- `Win32Emu.Win32.Kernel32Module` (backward compatible with `unsafe` keyword)
- `Win32Emu.Win32.Modules.DPlayXModule`
- `Win32Emu.Win32.Modules.DDrawModule`
- `Win32Emu.Win32.Modules.DInputModule`
- `Win32Emu.Win32.Modules.DSoundModule`
- `Win32Emu.Win32.Modules.User32Module`
- `Win32Emu.Win32.Modules.Gdi32Module`
- `Win32Emu.Win32.Modules.WinMMModule`
- `Win32Emu.Win32.Modules.Glide2xModule`

### Example Generated Code

**StdCallMeta.g.cs:**
```csharp
// <auto-generated/>
namespace Win32Emu.Win32
{
    public static class StdCallMeta
    {
        public static int GetArgBytes(string dll, string export)
        {
            switch ((dll.ToUpperInvariant(), export))
            {
                case ("DPLAYX.DLL", "DirectPlayCreate"): return 12;
                case ("DPLAYX.DLL", "DirectPlayEnumerateA"): return 8;
                // ... more exports
                default: throw new System.InvalidOperationException($"Missing arg bytes for {dll}!{export}");
            }
        }
    }
}
```

### 2. DllModuleExportInfo - For Export Metadata Queries

Automatically generates the `DllModuleExportInfo` helper class with methods to query export information without using reflection.

**DllModuleExportInfo.g.cs:**
```csharp
// <auto-generated/>
namespace Win32Emu.Win32
{
    public static class DllModuleExportInfo
    {
        public static bool IsExportImplemented(string dllName, string exportName, string? version = null)
        {
            switch ((dllName.ToUpperInvariant(), exportName.ToUpperInvariant()))
            {
                case ("DPLAYX.DLL", "DIRECTPLAYCREATE"): return true;
                case ("DPLAYX.DLL", "DIRECTPLAYENUMERATEA"): return true;
                // ... more exports
                default: return false;
            }
        }

        public static Dictionary<string, uint> GetAllExports(string dllName)
        {
            var exports = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
            switch (dllName.ToUpperInvariant())
            {
                case "DPLAYX.DLL":
                    exports["DirectPlayCreate"] = 1;
                    exports["DirectPlayEnumerateA"] = 2;
                    break;
                // ... more modules
            }
            return exports;
        }
    }
}
```

**Benefits of Source Generation:**
- **No reflection** - All lookups are compile-time switch statements
- **Type-safe** - Compiler errors if module names are wrong
- **Fast** - O(1) lookups instead of reflection overhead
- **AOT-friendly** - Works with ahead-of-time compilation
- **Deterministic** - Generated from source, not runtime introspection

## Best Practices

1. **Always specify ordinals**: Export ordinals are required for proper DLL emulation
2. **Use version strings for multiple versions**: When emulating different Windows versions, use version-specific attributes
3. **Document entry points**: If known, include entry point addresses for debugging
4. **Keep methods private**: Export methods should typically be private and called via `TryInvokeUnsafe()`
5. **Use DLL filenames**: When calling `DllModuleExportInfo` methods, use the DLL filename (e.g., "KERNEL32.DLL", "DPLAYX.DLL")

## Migration Guide

### All Modules Now Require Attributes

**Important**: The backward compatibility mode has been removed. All modules, including Kernel32Module, now require `[DllModuleExport]` attributes.

### Kernel32Module Migration

Kernel32Module has been fully migrated with all 48 exported methods now using `[DllModuleExport]` attributes. Each method's ordinal is defined directly on the method:

```csharp
[DllModuleExport(23)]
private unsafe uint GetVersion()
{
    // Implementation
}

[DllModuleExport(3)]
private unsafe uint ExitProcess(uint code)
{
    // Implementation
}
```

### Converting Existing Modules

Before:
```csharp
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

public Dictionary<string, uint> GetExportOrdinals()
{
    return new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase)
    {
        { "DirectPlayCreate", 1 },
    };
}
```

After:
```csharp
[DllModuleExport(1)]
private unsafe uint DirectPlayCreate(uint lpGUID, uint lplpDP, uint pUnkOuter)
{
    // Implementation
}

// GetExportOrdinals() can now use the generated helper
public Dictionary<string, uint> GetExportOrdinals()
{
    return DllModuleExportInfo.GetAllExports("DPLAYX.DLL");
}
```

## Implemented Features

The following features have been fully implemented:

### Auto-Generated GetExportOrdinals()

All modules now auto-generate their `GetExportOrdinals()` implementation from `[DllModuleExport]` attributes:

```csharp
public Dictionary<string, uint> GetExportOrdinals()
{
    // Auto-generated from [DllModuleExport] attributes
    return DllModuleExportInfo.GetAllExports("KERNEL32.DLL");
}
```

**Benefits:**
- No manual synchronization between attributes and ordinals dictionary
- Single source of truth for export metadata
- Automatically stays in sync with attribute changes

### Forwarded Exports Support

The system now fully supports forwarded exports (e.g., KERNEL32 -> KERNELBASE forwarding):

**Declaration:**
```csharp
// In KERNEL32.DLL module
[DllModuleExport(48, ForwardedTo = "KERNELBASE.GetVersionEx")]
private unsafe uint GetVersionEx()
{
    throw new NotImplementedException("This export is forwarded");
}
```

**Runtime Resolution:**
- `GetProcAddress` automatically detects forwarded exports
- Recursively resolves the forwarding chain
- Loads target DLL if not already loaded
- Returns the final export address

**API Support:**
```csharp
// Check if an export is forwarded
string? target = DllModuleExportInfo.GetForwardedExport("KERNEL32.DLL", "GetVersionEx");
// Returns: "KERNELBASE.GetVersionEx"
```

**Benefits:**
- Matches real Windows DLL forwarding behavior
- Supports multi-level forwarding chains
- Works with both PE exports and emulated modules
- No performance overhead for non-forwarded exports

### Enhanced GetProcAddress Integration

The `GetProcAddress` implementation in `Kernel32Module` now uses `DllModuleExportInfo` for export validation:

```csharp
// Check if export is implemented using DllModuleExportInfo
if (DllModuleExportInfo.IsExportImplemented(moduleName, procName))
{
    exportName = procName;
}
```

**Benefits:**
- Fast compile-time generated lookups (no reflection)
- Consistent with other export metadata queries
- Better error reporting for missing exports

## Future Enhancements

Potential future improvements:
- Automatic version detection based on emulated Windows version
- Export by name vs. ordinal distinction
- Enhanced forwarding chain diagnostics and debugging
